## Overview

Thrush CodeSynth sequence generators allow you to write JavaScript code that generates music through computation. Some exampels of what you can achieve using CodeSynth:
- **Create parameterized musical passages**, that play notes based on parameters received on invocation. For example, an appregiator can be programmed to receive a set of notes as parameters and generate an appregio part out of them.
- **Create passages that include randomness**. For example add randomness to note dynamics and timing to create more natural-sounding parts. Or perhaps choose between several accompaniment passages in random.
- **Create passages that respond to events**. By responding to events you can synchronize multiple parallel sequences of events.

## CodeSynth Basics

To use CodeSynth, you create a CodeSynth Sequence Generator. The sequence generator includes a definition of a [JavaScript generator function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*) that yields a sequence of CodeSynth **directives**; Thrush will execute these directives and generate events based on them. When invoking the generator function, Thrush will pass it a [`ThrushSequenceGenerationCalls`](/td/docs/code-synth-api/interfaces/ThrushSequenceGenerationCalls) object as an argument, which you can use to construct the directives yielded from the function and access various utilities.

The example below demonstrates a trivial CodeSynth sequence generator that plays two notes with a delay between them.

```jsx
/**
* @param {ThrushSequenceGenerationCalls} c
*/
function* mainSequence(c) {
  yield c.playNote("soft", 0, 0, 12);
  yield c.delay(0.2);
  yield c.playNote("soft", 0, 0, 24);
  yield c.delay(0.2);

}
```

Observe, in the example above:

1. The CodeSynth sequence declares a single generator function, `mainSeqeunce`.
1. `mainSequence` is declared to accept a single parameter of type [`ThrushSequenceGenerationCalls`](/td/docs/code-synth-api/interfaces/ThrushSequenceGenerationCalls).
1. `mainSequence` uses some methods in [`ThrushSequenceGenerationCalls`](/td/docs/code-synth-api/interfaces/ThrushSequenceGenerationCalls) to construct directives that comprise the generated sequence. In this example, we use:
    1. `playNote` to play a note on a synthesizer (we play two C notes, in different octaves).
    1. `delay` to delay the next generated event. 
1. `mainSequence` uses `yield` statements to yield generated events, one by one.


## Directive and Event Timing

Many CodeSynth directives cause the generation of one or more Thrush events. For example the `playNote` directive from the 
example above triggers the generation of a note play event.  Thrush events have a time attached to them,
based on which they're scheduled and acted upon. To save you the trouble of manually scheduling and timing events, Each Thrush CodeSynth generator function maintains an internal clock throughout its execution. Directives that generate timed events, such as `playNote`, use the "current time" value of that clock to schedule the event. Some directives update the current time; most notably:

- `delay` adds a fixed value to the current time.
- `playSequence` is used to "call" a sequence from within a CodeSynth generated sequence. Once the called sequence is exhausted, the current time is set to the time of the last event generated by it -- so that subsequent events follow events in the called sequence. 
- `waitFor` is used to pause the sequence until an event is broadcast. When the event is broadcast, the current time is set to the time at which it was broadcast.

The following code example illustrates these concepts:

```jsx
/**
* @param {ThrushSequenceGenerationCalls} c
*/
function* mainSequence(c) {
  // These 2 notes will play together
  yield c.playNote("soft", 0, 0, 12);
  yield c.playNote("soft", 0, 0, 24);
  yield c.delay(0.2);

  // This sequence will start playing 0.2 seconds after the notes above,
  const someSequence = ... ;          
  yield c.playSequence(someSequence);

  // This note will play once someSequence completes.
  yield c.playNote("soft", 0, 0, 12);

}
```

## Invoked Sequences 

A CodeSynth generator can play events from other event sequences ("invoked sequences") using **sequence invocation directives**.
Note that events from invoked sequences are always time-shifted by the current time as it was when the invocation occured. This means that the sequence invocation directives intuitively "start" the invoked sequences in-line with other generated events. 

Sequences can either be invoked synchronously or asynchronously. The `playSequence` directive invokes a sequence synchronously: 
the CodeSynth generator is temporarily suspended, and events are provided by the invoked sequence. When the 
invoked sequence is exhausted the current time of the CodeSynth generator is updated to the time of last event in the invoked 
sequence and the CodeSynth generator execution is resumed. The effect is that directives yielded after the `playSequence` 
directive generate events that are secheduled after the invoked sequence completes.  

To asynchronously invoke a sequence, use `startSequence`. When this directive is executed, events from the invoked sequence will be mixed together with subsequent events from the CodeSynth generator. CodeSynth generator is not suspended, as oppsosed to the `playSequence` case. 

Note that a CodeSynth sequence "ends" only after all invoked sequences end, regardless of whether they're invoked synchronously or asynchronously.

Some examples for sequence invocation behaviors are provided below:

```jsx
/**
* @param {ThrushSequenceGenerationCalls} c
*/
function* mainSequence(c) {
  // This sequence will play twice, one after the other.
  const someSequence = ... ;          
  yield c.playSequence(someSequence);
  yield c.playSequence(someSequence);

  // We can then have a Canon: play the same sequence with a time delay.
  // Note that realistically you'll want to use different channels for the second sequence to have polyphony.
  yield c.startSequence(someSequence);
  yield c.delay(0.2);
  yield c.startSequence(someSequence);

  // And another part to the Canon. In this case we're using sync invocation to wait until the last part ends.
  yield c.delay(0.2);
  yield c.playSequence(someSequence);

  // Tada
  yield c.playNote("soft", 0, 0, 24);
  yield c.delay(0.2);
}
```

## Creating Nested CodeSynth Sequences

CodeSynth allows you to create local, or nested, CodeSynth sequences using the `functionSequence` call. This call receives a 
CodeSynth generator function and returns a sequence handle that can be then used with `startSequence` or `playSequence`. This allows you to consturct complex passages from smaller managable CodeSynth generated sequenceas. The example below uses this technique to play a random passage several times:


```jsx
/**
* @param {ThrushSequenceGenerationCalls} c
*/
function* mainSequence(c) {
  const TEMPO = 0.2;

  const randomBells = (notes, instrumentId, tempo, count) => c.functionSequence(function* (c) {
    let channel = 0;
    for (let x = 0; x < count; x++) {
      const noteStep = Math.round(Math.random() * (notes.length - 1));
      yield c.playNote("soft", channel, instrumentId, notes[noteStep], { panning: Math.random(), volume: 0.25 });
      yield c.delay(tempo);
      channel++;
      if (channel > 1) {
        channel = 0;
      }
    }
  });
    
  yield c.playSequence(randomBells([24, 24, 36], 2, TEMPO / 2, 16));
  yield c.playSequence(randomBells([19, 24, 36], 2, TEMPO / 2, 16));
  yield c.playSequence(randomBells([20, 20, 32], 2, TEMPO / 2, 16));
}
```